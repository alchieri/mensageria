spring.application.name=mensageria

#Server Port
server.port=${PORT_SERVER:8082}

# Configuração do Actuator
# management.server.port=8082
# Para expor endpoints do Actuator (ex: health, info) via HTTP (opcional)
# management.endpoints.web.exposure.include=health,info

springdoc.show-actuator=false

# WhatsApp Cloud API Configuration
whatsapp.graph-api.base-url=https://graph.facebook.com/v22.0
whatsapp.cloud-api.phone-number-id=${WHATSAPP_API_PHONE_NUMBER_ID}

# WhatsApp Business API Configuration
whatsapp.business-api.base-url=https://graph.facebook.com/v22.0
whatsapp.business-api.waba-id=${WHATSAPP_API_WABA_ID}
whatsapp.api.token=${WHATSAPP_API_TOKEN}
whatsapp.webhook.verify-token=${WHATSAPP_WEBHOOK_VERIFY_TOKEN}
meta.app.secret=${META_APP_SECRET}
meta.app.id=${META_APP_ID}
whatsapp.flow.private-key.s3-bucket=${FLOW_PRIVATE_KEY_BUCKET}
whatsapp.flow.private-key.s3-key=${FLOW_PRIVATE_KEY_S3_KEY}

whatsapp.flow.public-key=${FLOW_PUBLIC_KEY_CONTENT}

#Logging (Opcional, mas útil para debug)
# logging.level.org.springframework.web.client.RestTemplate=DEBUG
logging.level.root=INFO
logging.level.com.br.alchieri.mensageria=DEBUG
logging.level.org.springframework.transaction=DEBUG
# logging.level.reactor.netty.http.client=DEBUG
# logging.level.org.springframework.web.reactive.function.client=DEBUG
logging.level.org.springframework.security=DEBUG
# logging.level.software.amazon.awssdk=DEBUG
logging.level.io.awspring.cloud.sqs=DEBUG
logging.level.org.springdoc=DEBUG

# Exemplo de padrão de log incluindo MDC traceId
# logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-}] %c{1.} - %m%n

# --- DataSource Configuration ---
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# --- JPA/Hibernate Configuration ---
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.show-sql=false

# --- JWT Configuration ---
# Gere uma chave secreta FORTE e longa (ex: usando openssl rand -base64 32)
# NÃO coloque a chave real aqui em produção! Use variável de ambiente.
jwt.secret.key=${JWT_SECRET_KEY}
jwt.expiration.ms=${JWT_EXPIRATION_MS}

spring.cache.type=jcache
spring.cache.jcache.config=classpath:ehcache.xml

# Desabilita o carregamento da URL padrão (que exige auth) ao abrir a página
springdoc.swagger-ui.disable-swagger-default-url=true

# Opcional: Ordena os grupos alfabeticamente
springdoc.swagger-ui.groups-order=DESC


# --- Bucket4j Rate Limiting ---
bucket4j.enabled=false
bucket4j.filters[0].http-status-code=TOO_MANY_REQUESTS
# Habilitar o filtro
# bucket4j.filters[0].enabled=true
# Cache a ser usado (jcache é comum, requer dependencia extra se não presente)
# Ou use 'hazelcast', 'ignite', 'redis' se configurados. 'jcache' é uma opção genérica.
# Para testes locais simples, pode não precisar de cache explícito se não tiver JCache.
# bucket4j.filters[0].cache-name=jcacheBucket4j

# URL pattern para aplicar o filtro (ex: todos endpoints protegidos da v1)
# bucket4j.filters[0].url=^/api/v1/(messages|templates|media)/.*
# bucket4j.filters[0].http-response-body={"success":false,"message":"Limite de taxa excedido. Tente novamente mais tarde.","data":null}
# bucket4j.filters[0].http-status-code=TOO_MANY_REQUESTS

# Estratégia: Identificar por IP (pode ser 'principalName' se quiser por cliente autenticado)
# bucket4j.filters[0].strategy=FIRST
# bucket4j.filters[0].expression=getRemoteAddr()
# bucket4j.filters[0].expression=getPrincipalName() // Alternativa: por usuário logado

# Configuração do "Balde" (limite)
# Exemplo: 100 requisições por minuto
# bucket4j.filters[0].rate-limits[0].bandwidths[0].capacity=100
# bucket4j.filters[0].rate-limits[0].bandwidths[0].time=1
# Opcional: Refill greedy/intervally
# bucket4j.filters[0].rate-limits[0].bandwidths[0].refill-speed=greedy


# --- Rate Limiting Programático (Bucket4j para Chamadas à Meta API) ---
whatsapp.meta.api.rate-limit.capacity=5
whatsapp.meta.api.rate-limit.refill-tokens=5
whatsapp.meta.api.rate-limit.refill-period-seconds=1

# --- AWS Configuration ---
# As credenciais serão buscadas automaticamente (Environment, Profile, Instance Metadata)
# Especifique a região onde as filas SQS foram criadas
cloud.aws.region.static=${AWS_REGION}
cloud.aws.credentials.access-key=${AWS_ACCESS_KEY_ID}
cloud.aws.credentials.secret-key=${AWS_SECRET_ACCESS_KEY}

# --- SQS Queue Names ---
sqs.queue.outgoing=whatsapp-outgoing-queue.fifo
sqs.queue.outgoing.dlq=whatsapp-outgoing-dlq.fifo

webhook-queue.name=whatsapp-webhook-events-queue.fifo

# --- AWS S3 Configuration ---
aws.s3.media-bucket-name=alchieri-mensageria-media

# --- Opcional: Configurações específicas do Listener SQS ---
# spring.cloud.aws.sqs.listener.max-number-of-messages=10 # Quantas msg buscar por vez
# spring.cloud.aws.sqs.listener.wait-time-out=20 # Long polling (segundos)